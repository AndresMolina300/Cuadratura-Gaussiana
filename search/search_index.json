{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introducci\u00f3n Contexto La cuadratura gaussiana es un m\u00e9todo num\u00e9rico de integraci\u00f3n que se utiliza para aproximar integrales definidas de manera eficiente. A diferencia de otros m\u00e9todos, como la regla del trapecio o Simpson, la cuadratura gaussiana logra una mayor precisi\u00f3n utilizando menos puntos de evaluaci\u00f3n, gracias a que los nodos y los pesos se eligen de forma \u00f3ptima a partir de los polinomios de Legendre. Objetivo del proyecto El objetivo de este trabajo es resolver la integral \\[ I = \\int_1^3 \\left( x^6 - x^2 \\sin(2x) \\right) dx \\] empleando el m\u00e9todo de cuadratura gaussiana, e identificar con qu\u00e9 valor de N se alcanza el resultado exacto. Organizaci\u00f3n de la documentaci\u00f3n Esta documentaci\u00f3n est\u00e1 organizada en varias secciones: - Explicaci\u00f3n : descripci\u00f3n del m\u00e9todo num\u00e9rico utilizado. - Tutorial : un ejemplo pr\u00e1ctico de ejecuci\u00f3n del c\u00f3digo. - Referencia : documentaci\u00f3n autom\u00e1tica de las funciones implementadas.","title":"Home"},{"location":"#introduccion","text":"","title":"Introducci\u00f3n"},{"location":"#contexto","text":"La cuadratura gaussiana es un m\u00e9todo num\u00e9rico de integraci\u00f3n que se utiliza para aproximar integrales definidas de manera eficiente. A diferencia de otros m\u00e9todos, como la regla del trapecio o Simpson, la cuadratura gaussiana logra una mayor precisi\u00f3n utilizando menos puntos de evaluaci\u00f3n, gracias a que los nodos y los pesos se eligen de forma \u00f3ptima a partir de los polinomios de Legendre.","title":"Contexto"},{"location":"#objetivo-del-proyecto","text":"El objetivo de este trabajo es resolver la integral \\[ I = \\int_1^3 \\left( x^6 - x^2 \\sin(2x) \\right) dx \\] empleando el m\u00e9todo de cuadratura gaussiana, e identificar con qu\u00e9 valor de N se alcanza el resultado exacto.","title":"Objetivo del proyecto"},{"location":"#organizacion-de-la-documentacion","text":"Esta documentaci\u00f3n est\u00e1 organizada en varias secciones: - Explicaci\u00f3n : descripci\u00f3n del m\u00e9todo num\u00e9rico utilizado. - Tutorial : un ejemplo pr\u00e1ctico de ejecuci\u00f3n del c\u00f3digo. - Referencia : documentaci\u00f3n autom\u00e1tica de las funciones implementadas.","title":"Organizaci\u00f3n de la documentaci\u00f3n"},{"location":"explanation/","text":"Explicaci\u00f3n del m\u00e9todo La cuadratura gaussiana es un m\u00e9todo num\u00e9rico para aproximar integrales definidas mediante una combinaci\u00f3n lineal de los valores de la funci\u00f3n en ciertos puntos especiales (llamados nodos ). Estos nodos y los coeficientes de ponderaci\u00f3n ( pesos ) se obtienen a partir de los polinomios de Legendre. La idea principal es transformar una integral en un intervalo arbitrario \\([a, b]\\) a la integral est\u00e1ndar en \\([-1, 1]\\) , usando el cambio de variable: \\[ x = \\frac{b-a}{2} \\, t + \\frac{b+a}{2} \\] donde \\(t \\in [-1, 1]\\) . Con esta transformaci\u00f3n, la integral queda: \\[ \\int_a^b f(x) \\, dx = \\frac{b-a}{2} \\int_{-1}^1 f\\!\\left(\\tfrac{b-a}{2}t + \\tfrac{b+a}{2}\\right) dt \\] y luego se aproxima con: \\[ \\int_a^b f(x)\\,dx \\approx \\frac{b-a}{2} \\sum_{i=1}^N w_i f(x_i) \\] donde: - \\(x_i\\) son los nodos de Legendre transformados al intervalo \\([a,b]\\) , - \\(w_i\\) son los pesos correspondientes, - \\(N\\) es el n\u00famero de puntos de cuadratura. Este m\u00e9todo es especialmente eficiente porque con relativamente pocos puntos logra una alta precisi\u00f3n en la aproximaci\u00f3n de integrales polin\u00f3micas y de otras funciones suaves.","title":"Explicaci\u00f3n"},{"location":"explanation/#explicacion-del-metodo","text":"La cuadratura gaussiana es un m\u00e9todo num\u00e9rico para aproximar integrales definidas mediante una combinaci\u00f3n lineal de los valores de la funci\u00f3n en ciertos puntos especiales (llamados nodos ). Estos nodos y los coeficientes de ponderaci\u00f3n ( pesos ) se obtienen a partir de los polinomios de Legendre. La idea principal es transformar una integral en un intervalo arbitrario \\([a, b]\\) a la integral est\u00e1ndar en \\([-1, 1]\\) , usando el cambio de variable: \\[ x = \\frac{b-a}{2} \\, t + \\frac{b+a}{2} \\] donde \\(t \\in [-1, 1]\\) . Con esta transformaci\u00f3n, la integral queda: \\[ \\int_a^b f(x) \\, dx = \\frac{b-a}{2} \\int_{-1}^1 f\\!\\left(\\tfrac{b-a}{2}t + \\tfrac{b+a}{2}\\right) dt \\] y luego se aproxima con: \\[ \\int_a^b f(x)\\,dx \\approx \\frac{b-a}{2} \\sum_{i=1}^N w_i f(x_i) \\] donde: - \\(x_i\\) son los nodos de Legendre transformados al intervalo \\([a,b]\\) , - \\(w_i\\) son los pesos correspondientes, - \\(N\\) es el n\u00famero de puntos de cuadratura. Este m\u00e9todo es especialmente eficiente porque con relativamente pocos puntos logra una alta precisi\u00f3n en la aproximaci\u00f3n de integrales polin\u00f3micas y de otras funciones suaves.","title":"Explicaci\u00f3n del m\u00e9todo"},{"location":"reference/","text":"Referencia de funciones A continuaci\u00f3n se listan las funciones del m\u00f3dulo cuadrature.py , con su documentaci\u00f3n generada autom\u00e1ticamente a partir de los docstrings. M\u00f3dulo de cuadratura gaussiana de Legendre para integrar en [a,b]. gauss_legendre_nodes_weights ( N ) Devuelve los nodos y pesos de Gauss-Legendre en [-1, 1]. Examples: >>> nodes , weights = gauss_legendre_nodes_weights ( 3 ) >>> len ( nodes ), len ( weights ) (3, 3) Parameters: Name Type Description Default N int N\u00famero de puntos de cuadratura (N >= 1). required Returns: Type Description Tuple [ ndarray , ndarray ] Tuple[np.ndarray, np.ndarray]: Arreglos con nodos y pesos. Source code in cuadrature.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def gauss_legendre_nodes_weights ( N : int ) -> Tuple [ np . ndarray , np . ndarray ]: \"\"\"Devuelve los nodos y pesos de Gauss-Legendre en [-1, 1]. Examples: >>> nodes, weights = gauss_legendre_nodes_weights(3) >>> len(nodes), len(weights) (3, 3) Args: N (int): N\u00famero de puntos de cuadratura (N >= 1). Returns: Tuple[np.ndarray, np.ndarray]: Arreglos con nodos y pesos. \"\"\" if N < 1 : raise ValueError ( \"N debe ser >= 1\" ) nodes , weights = np . polynomial . legendre . leggauss ( N ) return nodes , weights gaussian_quadrature ( f , a , b , N ) Aproxima \\(\\int_a^b f(x)\\,dx\\) usando cuadratura gaussiana de N puntos. Examples: >>> f = lambda x : x ** 2 >>> round ( gaussian_quadrature ( f , 0.0 , 1.0 , 2 ), 6 ) 0.333333 Parameters: Name Type Description Default f Callable [[ float ], float ] Funci\u00f3n escalar a integrar. required a float L\u00edmite inferior. required b float L\u00edmite superior. required N int N\u00famero de puntos de cuadratura. required Returns: Name Type Description float float Aproximaci\u00f3n de la integral en [a,b]. Source code in cuadrature.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 def gaussian_quadrature ( f : Callable [[ float ], float ], a : float , b : float , N : int ) -> float : \"\"\"Aproxima \\\\(\\\\int_a^b f(x)\\\\,dx\\\\) usando cuadratura gaussiana de N puntos. Examples: >>> f = lambda x: x**2 >>> round(gaussian_quadrature(f, 0.0, 1.0, 2), 6) 0.333333 Args: f (Callable[[float], float]): Funci\u00f3n escalar a integrar. a (float): L\u00edmite inferior. b (float): L\u00edmite superior. N (int): N\u00famero de puntos de cuadratura. Returns: float: Aproximaci\u00f3n de la integral en [a,b]. \"\"\" nodes , weights = gauss_legendre_nodes_weights ( N ) nodes , weights = scale_interval ( a , b , nodes , weights ) # Evaluamos de forma segura si f no est\u00e1 vectorizada vals = np . array ([ f ( float ( x )) for x in nodes ], dtype = float ) return float ( np . sum ( weights * vals )) scale_interval ( a , b , nodes , weights ) Escala nodos y pesos de [-1,1] al intervalo [a,b]. Examples: >>> n , w = scale_interval ( 1.0 , 3.0 , np . array ([ - 1.0 , 1.0 ]), np . array ([ 1.0 , 1.0 ])) >>> float ( n . min ()) >= 1.0 and float ( n . max ()) <= 3.0 True Parameters: Name Type Description Default a float L\u00edmite inferior del intervalo. required b float L\u00edmite superior del intervalo. required nodes ndarray Nodos en [-1,1]. required weights ndarray Pesos en [-1,1]. required Returns: Type Description Tuple [ ndarray , ndarray ] Tuple[np.ndarray, np.ndarray]: Nodos y pesos re-escalados a [a,b]. Source code in cuadrature.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 def scale_interval ( a : float , b : float , nodes : np . ndarray , weights : np . ndarray ) -> Tuple [ np . ndarray , np . ndarray ]: \"\"\"Escala nodos y pesos de [-1,1] al intervalo [a,b]. Examples: >>> n, w = scale_interval(1.0, 3.0, np.array([-1.0, 1.0]), np.array([1.0, 1.0])) >>> float(n.min()) >= 1.0 and float(n.max()) <= 3.0 True Args: a (float): L\u00edmite inferior del intervalo. b (float): L\u00edmite superior del intervalo. nodes (np.ndarray): Nodos en [-1,1]. weights (np.ndarray): Pesos en [-1,1]. Returns: Tuple[np.ndarray, np.ndarray]: Nodos y pesos re-escalados a [a,b]. \"\"\" half = 0.5 * ( b - a ) mid = 0.5 * ( a + b ) new_nodes = half * nodes + mid new_weights = half * weights return new_nodes , new_weights","title":"Referencia"},{"location":"reference/#referencia-de-funciones","text":"A continuaci\u00f3n se listan las funciones del m\u00f3dulo cuadrature.py , con su documentaci\u00f3n generada autom\u00e1ticamente a partir de los docstrings. M\u00f3dulo de cuadratura gaussiana de Legendre para integrar en [a,b].","title":"Referencia de funciones"},{"location":"reference/#cuadrature.gauss_legendre_nodes_weights","text":"Devuelve los nodos y pesos de Gauss-Legendre en [-1, 1]. Examples: >>> nodes , weights = gauss_legendre_nodes_weights ( 3 ) >>> len ( nodes ), len ( weights ) (3, 3) Parameters: Name Type Description Default N int N\u00famero de puntos de cuadratura (N >= 1). required Returns: Type Description Tuple [ ndarray , ndarray ] Tuple[np.ndarray, np.ndarray]: Arreglos con nodos y pesos. Source code in cuadrature.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def gauss_legendre_nodes_weights ( N : int ) -> Tuple [ np . ndarray , np . ndarray ]: \"\"\"Devuelve los nodos y pesos de Gauss-Legendre en [-1, 1]. Examples: >>> nodes, weights = gauss_legendre_nodes_weights(3) >>> len(nodes), len(weights) (3, 3) Args: N (int): N\u00famero de puntos de cuadratura (N >= 1). Returns: Tuple[np.ndarray, np.ndarray]: Arreglos con nodos y pesos. \"\"\" if N < 1 : raise ValueError ( \"N debe ser >= 1\" ) nodes , weights = np . polynomial . legendre . leggauss ( N ) return nodes , weights","title":"gauss_legendre_nodes_weights"},{"location":"reference/#cuadrature.gaussian_quadrature","text":"Aproxima \\(\\int_a^b f(x)\\,dx\\) usando cuadratura gaussiana de N puntos. Examples: >>> f = lambda x : x ** 2 >>> round ( gaussian_quadrature ( f , 0.0 , 1.0 , 2 ), 6 ) 0.333333 Parameters: Name Type Description Default f Callable [[ float ], float ] Funci\u00f3n escalar a integrar. required a float L\u00edmite inferior. required b float L\u00edmite superior. required N int N\u00famero de puntos de cuadratura. required Returns: Name Type Description float float Aproximaci\u00f3n de la integral en [a,b]. Source code in cuadrature.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 def gaussian_quadrature ( f : Callable [[ float ], float ], a : float , b : float , N : int ) -> float : \"\"\"Aproxima \\\\(\\\\int_a^b f(x)\\\\,dx\\\\) usando cuadratura gaussiana de N puntos. Examples: >>> f = lambda x: x**2 >>> round(gaussian_quadrature(f, 0.0, 1.0, 2), 6) 0.333333 Args: f (Callable[[float], float]): Funci\u00f3n escalar a integrar. a (float): L\u00edmite inferior. b (float): L\u00edmite superior. N (int): N\u00famero de puntos de cuadratura. Returns: float: Aproximaci\u00f3n de la integral en [a,b]. \"\"\" nodes , weights = gauss_legendre_nodes_weights ( N ) nodes , weights = scale_interval ( a , b , nodes , weights ) # Evaluamos de forma segura si f no est\u00e1 vectorizada vals = np . array ([ f ( float ( x )) for x in nodes ], dtype = float ) return float ( np . sum ( weights * vals ))","title":"gaussian_quadrature"},{"location":"reference/#cuadrature.scale_interval","text":"Escala nodos y pesos de [-1,1] al intervalo [a,b]. Examples: >>> n , w = scale_interval ( 1.0 , 3.0 , np . array ([ - 1.0 , 1.0 ]), np . array ([ 1.0 , 1.0 ])) >>> float ( n . min ()) >= 1.0 and float ( n . max ()) <= 3.0 True Parameters: Name Type Description Default a float L\u00edmite inferior del intervalo. required b float L\u00edmite superior del intervalo. required nodes ndarray Nodos en [-1,1]. required weights ndarray Pesos en [-1,1]. required Returns: Type Description Tuple [ ndarray , ndarray ] Tuple[np.ndarray, np.ndarray]: Nodos y pesos re-escalados a [a,b]. Source code in cuadrature.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 def scale_interval ( a : float , b : float , nodes : np . ndarray , weights : np . ndarray ) -> Tuple [ np . ndarray , np . ndarray ]: \"\"\"Escala nodos y pesos de [-1,1] al intervalo [a,b]. Examples: >>> n, w = scale_interval(1.0, 3.0, np.array([-1.0, 1.0]), np.array([1.0, 1.0])) >>> float(n.min()) >= 1.0 and float(n.max()) <= 3.0 True Args: a (float): L\u00edmite inferior del intervalo. b (float): L\u00edmite superior del intervalo. nodes (np.ndarray): Nodos en [-1,1]. weights (np.ndarray): Pesos en [-1,1]. Returns: Tuple[np.ndarray, np.ndarray]: Nodos y pesos re-escalados a [a,b]. \"\"\" half = 0.5 * ( b - a ) mid = 0.5 * ( a + b ) new_nodes = half * nodes + mid new_weights = half * weights return new_nodes , new_weights","title":"scale_interval"},{"location":"tutorials/","text":"Tutorial de uso (paso a paso, con LaTeX) Este proyecto implementa cuadratura gaussiana de Legendre para aproximar la integral \\[ I=\\int_{1}^{3}\\bigl(x^6 - x^2\\sin(2x)\\bigr)\\,dx. \\] A continuaci\u00f3n se muestra el flujo completo que sigue el programa. 1) Definir la funci\u00f3n a integrar Sea [ f(x)=x^6 - x^2\\sin(2x). ] En el c\u00f3digo de Python, se implementa como una funci\u00f3n f(x) . 2) Transformar el intervalo \\([1,3]\\) a \\([-1,1]\\) La cuadratura de Gauss-Legendre trabaja de forma can\u00f3nica en \\([-1,1]\\) . Para un intervalo \\([a,b]\\) usamos el cambio de variable [ x(t)=\\frac{b-a}{2}\\,t+\\frac{a+b}{2},\\qquad t\\in[-1,1], ] con [ dx=\\frac{b-a}{2}\\,dt. ] En nuestro caso \\(a=1,\\; b=3\\) , por lo que [ x(t)=\\frac{3-1}{2}\\,t+\\frac{3+1}{2}=t+2,\\qquad dx=\\frac{3-1}{2}\\,dt=1\\,dt. ] 3) F\u00f3rmula de cuadratura La aproximaci\u00f3n con \\(N\\) puntos (nodos \\(t_i\\) y pesos \\(w_i\\) de Legendre en \\([-1,1]\\) ) es [ \\int_a^b f(x)\\,dx \\;\\approx\\; \\frac{b-a}{2}\\sum_{i=1}^{N} w_i\\, f!\\bigl(x(t_i)\\bigr). ] Para \\([1,3]\\) esto queda [ I \\;\\approx\\; \\frac{3-1}{2}\\sum_{i=1}^{N} w_i\\, f!\\bigl(t_i+2\\bigr)\\;=\\;\\sum_{i=1}^{N} w_i\\, f(t_i+2). ] 4) Algoritmo (qu\u00e9 hace el script) Calcula nodos \\(\\{t_i\\}_{i=1}^N\\) y pesos \\(\\{w_i\\}_{i=1}^N\\) de Legendre en \\([-1,1]\\) . Eval\u00faa \\(f\\) en los puntos transformados \\(x_i=t_i+2\\) . Acumula la suma \\(\\displaystyle \\sum_{i=1}^{N} w_i\\, f(x_i)\\) . Imprime el valor aproximado de \\(I\\) para el \\(N\\) usado.","title":"Tutorial"},{"location":"tutorials/#tutorial-de-uso-paso-a-paso-con-latex","text":"Este proyecto implementa cuadratura gaussiana de Legendre para aproximar la integral \\[ I=\\int_{1}^{3}\\bigl(x^6 - x^2\\sin(2x)\\bigr)\\,dx. \\] A continuaci\u00f3n se muestra el flujo completo que sigue el programa.","title":"Tutorial de uso (paso a paso, con LaTeX)"},{"location":"tutorials/#1-definir-la-funcion-a-integrar","text":"Sea [ f(x)=x^6 - x^2\\sin(2x). ] En el c\u00f3digo de Python, se implementa como una funci\u00f3n f(x) .","title":"1) Definir la funci\u00f3n a integrar"},{"location":"tutorials/#2-transformar-el-intervalo-13-a-11","text":"La cuadratura de Gauss-Legendre trabaja de forma can\u00f3nica en \\([-1,1]\\) . Para un intervalo \\([a,b]\\) usamos el cambio de variable [ x(t)=\\frac{b-a}{2}\\,t+\\frac{a+b}{2},\\qquad t\\in[-1,1], ] con [ dx=\\frac{b-a}{2}\\,dt. ] En nuestro caso \\(a=1,\\; b=3\\) , por lo que [ x(t)=\\frac{3-1}{2}\\,t+\\frac{3+1}{2}=t+2,\\qquad dx=\\frac{3-1}{2}\\,dt=1\\,dt. ]","title":"2) Transformar el intervalo \\([1,3]\\) a \\([-1,1]\\)"},{"location":"tutorials/#3-formula-de-cuadratura","text":"La aproximaci\u00f3n con \\(N\\) puntos (nodos \\(t_i\\) y pesos \\(w_i\\) de Legendre en \\([-1,1]\\) ) es [ \\int_a^b f(x)\\,dx \\;\\approx\\; \\frac{b-a}{2}\\sum_{i=1}^{N} w_i\\, f!\\bigl(x(t_i)\\bigr). ] Para \\([1,3]\\) esto queda [ I \\;\\approx\\; \\frac{3-1}{2}\\sum_{i=1}^{N} w_i\\, f!\\bigl(t_i+2\\bigr)\\;=\\;\\sum_{i=1}^{N} w_i\\, f(t_i+2). ]","title":"3) F\u00f3rmula de cuadratura"},{"location":"tutorials/#4-algoritmo-que-hace-el-script","text":"Calcula nodos \\(\\{t_i\\}_{i=1}^N\\) y pesos \\(\\{w_i\\}_{i=1}^N\\) de Legendre en \\([-1,1]\\) . Eval\u00faa \\(f\\) en los puntos transformados \\(x_i=t_i+2\\) . Acumula la suma \\(\\displaystyle \\sum_{i=1}^{N} w_i\\, f(x_i)\\) . Imprime el valor aproximado de \\(I\\) para el \\(N\\) usado.","title":"4) Algoritmo (qu\u00e9 hace el script)"}]}