{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introducci\u00f3n","text":""},{"location":"#contexto","title":"Contexto","text":"<p>La cuadratura gaussiana es un m\u00e9todo num\u00e9rico de integraci\u00f3n que se utiliza para aproximar integrales definidas de manera eficiente. A diferencia de otros m\u00e9todos, como la regla del trapecio o Simpson, la cuadratura gaussiana logra una mayor precisi\u00f3n utilizando menos puntos de evaluaci\u00f3n, gracias a que los nodos y los pesos se eligen de forma \u00f3ptima a partir de los polinomios de Legendre.</p>"},{"location":"#objetivo-del-proyecto","title":"Objetivo del proyecto","text":"<p>El objetivo de este trabajo es resolver la integral</p> \\[ I = \\int_1^3 \\left( x^6 - x^2 \\sin(2x) \\right) dx \\] <p>empleando el m\u00e9todo de cuadratura gaussiana, e identificar con qu\u00e9 valor de <code>N</code> se alcanza el resultado exacto.</p>"},{"location":"#organizacion-de-la-documentacion","title":"Organizaci\u00f3n de la documentaci\u00f3n","text":"<p>Esta documentaci\u00f3n est\u00e1 organizada en varias secciones: - Explicaci\u00f3n: descripci\u00f3n del m\u00e9todo num\u00e9rico utilizado. - Tutorial: un ejemplo pr\u00e1ctico de ejecuci\u00f3n del c\u00f3digo. - Referencia: documentaci\u00f3n autom\u00e1tica de las funciones implementadas.</p>"},{"location":"explanation/","title":"Explicaci\u00f3n del m\u00e9todo","text":"<p>La cuadratura gaussiana es un m\u00e9todo num\u00e9rico para aproximar integrales definidas mediante una combinaci\u00f3n lineal de los valores de la funci\u00f3n en ciertos puntos especiales (llamados nodos). Estos nodos y los coeficientes de ponderaci\u00f3n (pesos) se obtienen a partir de los polinomios de Legendre.</p> <p>La idea principal es transformar una integral en un intervalo arbitrario \\([a, b]\\) a la integral est\u00e1ndar en \\([-1, 1]\\), usando el cambio de variable:</p> \\[ x = \\frac{b-a}{2} \\, t + \\frac{b+a}{2} \\] <p>donde \\(t \\in [-1, 1]\\). Con esta transformaci\u00f3n, la integral queda:</p> \\[ \\int_a^b f(x) \\, dx = \\frac{b-a}{2} \\int_{-1}^1 f\\!\\left(\\tfrac{b-a}{2}t + \\tfrac{b+a}{2}\\right) dt \\] <p>y luego se aproxima con:</p> \\[ \\int_a^b f(x)\\,dx \\approx \\frac{b-a}{2} \\sum_{i=1}^N w_i f(x_i) \\] <p>donde: - \\(x_i\\) son los nodos de Legendre transformados al intervalo \\([a,b]\\), - \\(w_i\\) son los pesos correspondientes, - \\(N\\) es el n\u00famero de puntos de cuadratura.</p> <p>Este m\u00e9todo es especialmente eficiente porque con relativamente pocos puntos logra una alta precisi\u00f3n en la aproximaci\u00f3n de integrales polin\u00f3micas y de otras funciones suaves.</p>"},{"location":"reference/","title":"Referencia","text":"<p>La siguiente documentaci\u00f3n fue generada autom\u00e1ticamente a partir del m\u00f3dulo <code>cuadrature.py</code>.</p>"},{"location":"reference/#cuadrature.integrando","title":"<code>integrando(x)</code>","text":"<p>Calcula el valor de la funci\u00f3n a integrar.</p> <p>La funci\u00f3n es: f(x) = x^6 - x^2 * sin(2x)</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>Punto donde se eval\u00faa la funci\u00f3n.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Valor de f(x).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; integrando(1.0)\n1.0 - 1.0 * sin(2.0)\n</code></pre> Source code in <code>cuadrature.py</code> <pre><code>def integrando(x: float) -&gt; float:\n    \"\"\"\n    Calcula el valor de la funci\u00f3n a integrar.\n\n    La funci\u00f3n es:\n    f(x) = x^6 - x^2 * sin(2x)\n\n    Args:\n        x (float): Punto donde se eval\u00faa la funci\u00f3n.\n\n    Returns:\n        float: Valor de f(x).\n\n    Examples:\n        &gt;&gt;&gt; integrando(1.0)\n        1.0 - 1.0 * sin(2.0)\n    \"\"\"\n    return x**6 - x**2 * np.sin(2*x)\n</code></pre>"},{"location":"reference/#cuadrature.sum_riemann","title":"<code>sum_riemann(N, a, b)</code>","text":"<p>Calcula la aproximaci\u00f3n de la integral definida usando cuadratura gaussiana con N nodos de Legendre.</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <code>int</code> <p>N\u00famero de nodos de cuadratura.</p> required <code>a</code> <code>float</code> <p>L\u00edmite inferior del intervalo.</p> required <code>b</code> <code>float</code> <p>L\u00edmite superior del intervalo.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Aproximaci\u00f3n num\u00e9rica de la integral en [a,b].</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; sum_riemann(2, 1.0, 3.0)\nAproximaci\u00f3n num\u00e9rica (valor aproximado).\n</code></pre> Source code in <code>cuadrature.py</code> <pre><code>def sum_riemann(N: int, a: float, b: float) -&gt; float:\n    \"\"\"\n    Calcula la aproximaci\u00f3n de la integral definida usando\n    cuadratura gaussiana con N nodos de Legendre.\n\n    Args:\n        N (int): N\u00famero de nodos de cuadratura.\n        a (float): L\u00edmite inferior del intervalo.\n        b (float): L\u00edmite superior del intervalo.\n\n    Returns:\n        float: Aproximaci\u00f3n num\u00e9rica de la integral en [a,b].\n\n    Examples:\n        &gt;&gt;&gt; sum_riemann(2, 1.0, 3.0)\n        Aproximaci\u00f3n num\u00e9rica (valor aproximado).\n    \"\"\"\n    # Obtener nodos y pesos de Legendre en [-1, 1]\n    t, w = np.polynomial.legendre.leggauss(N)\n\n    # Cambio de variable para llevar [a,b] a [-1,1]\n    x = 0.5 * (b - a) * t + 0.5 * (a + b)\n    dx = 0.5 * (b - a)\n\n    # Suma ponderada\n    return np.sum(w * integrando(x)) * dx\n</code></pre>"},{"location":"tutorials/","title":"Tutorial de uso (paso a paso, con LaTeX)","text":"<p>Este proyecto implementa cuadratura gaussiana de Legendre para aproximar la integral</p> \\[ I=\\int_{1}^{3}\\bigl(x^6 - x^2\\sin(2x)\\bigr)\\,dx. \\] <p>A continuaci\u00f3n se muestra el flujo completo que sigue el programa.</p>"},{"location":"tutorials/#1-definir-la-funcion-a-integrar","title":"1) Definir la funci\u00f3n a integrar","text":"<p>Sea [ f(x)=x^6 - x^2\\sin(2x). ]</p> <p>En el c\u00f3digo de Python, se implementa como una funci\u00f3n <code>f(x)</code>.</p>"},{"location":"tutorials/#2-transformar-el-intervalo-13-a-11","title":"2) Transformar el intervalo \\([1,3]\\) a \\([-1,1]\\)","text":"<p>La cuadratura de Gauss-Legendre trabaja de forma can\u00f3nica en \\([-1,1]\\). Para un intervalo \\([a,b]\\) usamos el cambio de variable [ x(t)=\\frac{b-a}{2}\\,t+\\frac{a+b}{2},\\qquad t\\in[-1,1], ] con [ dx=\\frac{b-a}{2}\\,dt. ] En nuestro caso \\(a=1,\\; b=3\\), por lo que [ x(t)=\\frac{3-1}{2}\\,t+\\frac{3+1}{2}=t+2,\\qquad dx=\\frac{3-1}{2}\\,dt=1\\,dt. ]</p>"},{"location":"tutorials/#3-formula-de-cuadratura","title":"3) F\u00f3rmula de cuadratura","text":"<p>La aproximaci\u00f3n con \\(N\\) puntos (nodos \\(t_i\\) y pesos \\(w_i\\) de Legendre en \\([-1,1]\\)) es [ \\int_a^b f(x)\\,dx \\;\\approx\\; \\frac{b-a}{2}\\sum_{i=1}^{N} w_i\\, f!\\bigl(x(t_i)\\bigr). ] Para \\([1,3]\\) esto queda [ I \\;\\approx\\; \\frac{3-1}{2}\\sum_{i=1}^{N} w_i\\, f!\\bigl(t_i+2\\bigr)\\;=\\;\\sum_{i=1}^{N} w_i\\, f(t_i+2). ]</p>"},{"location":"tutorials/#4-algoritmo-que-hace-el-script","title":"4) Algoritmo (qu\u00e9 hace el script)","text":"<ol> <li>Calcula nodos \\(\\{t_i\\}_{i=1}^N\\) y pesos \\(\\{w_i\\}_{i=1}^N\\) de Legendre en \\([-1,1]\\).</li> <li>Eval\u00faa \\(f\\) en los puntos transformados \\(x_i=t_i+2\\).</li> <li>Acumula la suma \\(\\displaystyle \\sum_{i=1}^{N} w_i\\, f(x_i)\\).</li> <li>Imprime el valor aproximado de \\(I\\) para el \\(N\\) usado.</li> </ol>"}]}